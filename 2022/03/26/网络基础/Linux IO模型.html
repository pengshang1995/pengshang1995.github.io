<hr>
<p>title: Linux IO模型<br>date: 2019-03-22 10:26:05<br>tags:</p>
<hr>
<p>#概念说明</p>
<ul>
<li>用户空间和内核空间</li>
<li>进程切换</li>
<li>进程堵塞</li>
<li>文件描述符</li>
<li>缓存IO</li>
</ul>
<h3 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h3><p>操作系统的核心是内核，独立于普通应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保存内核的安全，操作系统将虚拟空间划分为两部分，一部分是内核空间，一部分为用户空间。</p>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。</p>
<h3 id="进程堵塞"><a href="#进程堵塞" class="headerlink" title="进程堵塞"></a>进程堵塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。<strong>当进程进入阻塞状态，是不占用CPU资源的。</strong></p>
<h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念</p>
<h3 id="缓存IO"><a href="#缓存IO" class="headerlink" title="缓存IO"></a>缓存IO</h3><p>缓存IO又被称作标准IO，大部分文件系统默认的IO操作都是缓存IO。数据会被先拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<h1 id="Linux-IO模型"><a href="#Linux-IO模型" class="headerlink" title="Linux IO模型"></a>Linux IO模型</h1><p>网络IO的本质是socket的读取，socket在linux系统被抽象为流，IO可以理解为对流的操作。<br>常见的IO模型有阻塞、非阻塞、IO多路复用，异步</p>
<h3 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h3><p>同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在linux中，默认情况下所有的socket都是blocking。它符合人们最常见的思考逻辑。阻塞就是进程 “被” 休息, CPU处理其它进程去了。</p>
<h3 id="同步非堵塞IO"><a href="#同步非堵塞IO" class="headerlink" title="同步非堵塞IO"></a>同步非堵塞IO</h3><p>同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。</p>
<blockquote>
<p>对比同步阻塞IO<br>优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。<br>缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</p>
</blockquote>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。<br>当需要同时处理多个客户端接入请求时，可以利用多线程或者IO多路复用技术进行处理。IO多路复用的最大优势就是系统开销小，系统不需要额外创建进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源。</p>
<h2 id="异步非阻塞-IO"><a href="#异步非阻塞-IO" class="headerlink" title="异步非阻塞 IO"></a>异步非阻塞 IO</h2><p>相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的</p>
